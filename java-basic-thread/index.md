# java基础并发系列-初识线程


### 1. 线程的8大核心基础知识

#### 1.实现多线程的几种方式

实现多线程的正确方法是2种：

- 实现 Runnable 接口 
- 继承 Thread 类

1. 实现Runnable接口好在哪里？

继承Thread类是不推荐的，因为它有以下的一些缺点： 

- 从代码架构角度：具体的任务（run方法）应该和“创建和运行线程的机制（Thread类）”解耦，用runnable对象可以实现解耦。 
- 使用继承Thread的方式的话，那么每次想新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大（比如重头开始创建一个线程、执行完毕以后再销毁等。如果线程的实际工作内容，也就是run()函数里只是简单的打印一行文字的话，那么可能线程的实际工作内容还不如损耗来的大）。如果使用Runnable和线程池，就可以大大减小这样的损耗。 
- 继承Thread类以后，由于Java语言不支持双继承，这样就无法再继承其他的类，限制了可扩展性。 通常我们优先选择方法1。

2. 两种方法的本质对比 
方法一和方法二，也就是“实现Runnable接口并传入Thread类”和“继承Thread类然后重写run()”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源： 

``` java
@Override 
public void run() { 
	if (target != null) { 
		target.run(); 
	} 
} 
```

- 方法一：最终调用target.run(); 
- 方法二：run()整个都被重写

3. 有多少种实现线程的方法？ 答题思路，以下5点：


- 从不同的角度看，会有不同的答案。 
- 典型答案是两种，分别是实现Runnable接口和继承Thread类，然后具体展开说； 
- 但是，我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的，

run方法的代码如下：

``` java
@Override 
public void run() { 
	if (target != null) { 
		target.run(); 
	} 
} 
```

方法一和方法二，也就是“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源： 
方法一：最终调用target.run(); 
方法二：run()整个都被重写 然后具体展开说其他方式； 

- 还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。 
- 结论:我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现。第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnable实例传给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是它们的本质都逃不出刚才所说的范围。 以上这种描述比直接回答一种、两种、多种都更准确。

#### 2. 启动线程的方式

start() 和 run() 方法的比较

正确的启动线程的方式是调用 `start()` 方法，而直接调用 `run()` 方法和调用普通方法没有任何区别

1. start方法的执行流程是什么？
- 检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行中或者已结束的线程，都不能再次启动，详见CantStartTwice10类）
- 将当前线程加入到线程组 
- 调用start0()方法启动线程 

注意点： start方法是被synchronized修饰的方法，可以保证线程安全； 由JVM创建的main方法线程和system组线程，并不会通过start来启动。

#### 3. 如何正确停止线程

1. Java中停止线程的原则是什么？ 

在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该停止运行了”，被终止的线程自身拥有决定权（决定是否、以及何时停止），这依赖于请求停止方和被停止方都遵守一种约定好的编码规范。

任务和线程的启动很容易。在大多数时候,我们都会让它们运行直到结束,或者让它们自行停止。然而,有时候我们希望提前结束任务或线程,或许是因为用户取消了操作,或者服务需要被快速关闭，或者是运行超时或出错了。

要使任务和线程能安全、快速、可靠地停止下来,并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断( Interruption),这是一种协作机制,能够使一个线程终止另一个线程的当前工作。 

这种协作式的方法是必要的,我们很少希望某个任务、线程或服务立即停止,因为这种立即停止会使共享的数据结构处于不一致的状态。相反,在编写任务和服务时可以使用一种协作的方式:当需要停止时,它们首先会清除当前正在执行的工作,然后再结束。这提供了更好的灵活性,因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。 

生命周期结束(End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂,而这个在程序设计中非常重要的要素却经常被忽略。一个在行为良好的软件与勉强运的软件之间的最主要区别就是,行为良好的软件能很完善地处理失败、关闭和取消等过程。 

2. 处理中断的最好方法是什么？ 

优先选择在方法上抛出异常。 

用`throws InterruptedException` 标记你的方法，不采用try 语句块捕获异常，以便于该异常可以传递到顶层，让run方法可以捕获这一异常，例如： 

``` java
void subTask() throws InterruptedException { 
	sleep(delay); 
} 
```

由于run方法内无法抛出`checked Exception`（只能用try catch），顶层方法必须处理该异常，避免了漏掉或者被吞掉的情况，增强了代码的健壮性。

3. 如果不能抛出中断，要怎么做？ 

如果不想或无法传递InterruptedException（例如用run方法的时候，就不让该方法`throws InterruptedException`），那么应该选择在catch 子句中调用`Thread.currentThread().interrupt()` 来恢复设置中断状态，以便于在后续的执行依然能够检查到刚才发生了中断。 

线程在sleep期间被中断，并且由catch捕获到该中断，并重新设置了中断状态，以便于可以在下一个循环的时候检测到中断状态，正常退出。

4. 为什么用volatile停止线程不够全面 

解答：这种做法是错误的，或者说是不够全面的，在某些情况下虽然可用，但是某些情况下有严重问题。 

这种方法在《Java并发编程实战》中被明确指出了缺陷，我们一起来看看缺陷在哪里：

此方法错误的原因在于，如果我们遇到了线程长时间阻塞（这是一种很常见的情况，例如生产者消费者模式中就存在这样的情况），就没办法及时唤醒它，或者永远都无法唤醒该线程，而interrupt设计之初就是把wait等长期阻塞作为一种特殊情况考虑在内了，我们应该用interrupt思维来停止线程。

5. 面试题1: 如何停止线程？

- 原理：用interrupt来请求线程停止而不是强制，好处是安全。

- 想停止线程，要请求方、被停止方、子方法被调用方相互配合才行：
a) 作为被停止方：每次循环中或者适时检查中断信号，并且在可能抛出InterrupedException的地方处理该中断信号； 
b) 请求方：发出中断信号；
c) 子方法调用方（被线程调用的方法的作者）要注意：优先在方法层面抛出InterrupedException，或者检查到中断信号时，再次设置中断状态； 

- 最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况

6. 面试题2: 无法响应中断时如何停止线程？

如果线程阻塞是由于调用了 wait()，sleep() 或 join() 方法，你可以中断线程，通过抛出 InterruptedException 异常来唤醒该线程。 

但是对于不能响应InterruptedException的阻塞，很遗憾，并没有一个通用的解决方案。 

但是我们可以利用特定的其它的可以响应中断的方法，比如ReentrantLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。

答案有很多种，因为有很多原因会造成线程阻塞，所以针对不同情况，唤起的方法也不同。

总结就是说如果不支持响应中断，就要用特定方法来唤起，没有万能药。

#### 4. 线程的生命周期

![线程的生命周期](https://i.loli.net/2020/07/11/tThRBDbpjIqZJ7e.png)

答题思路： 
先讲6个圆圈内的状态名，再讲转换路径（例如new只能跳转到runnable），最后讲转移条件。

#### 5. Object的wait/notify/notifyAll以及Thread的sleep的特点

讲讲sleep方法的特点？

sleep方法可以让线程进入Timed_Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态。

wait和sleep方法的异同？ 

你知道wait和sleep方法的异同吗？ 
解答：
相同 

1. Wait和sleep方法都可以使线程阻塞，对应线程状态是Waiting或Time_Waiting。 
2. wait和sleep方法都可以响应中断Thread.interrupt()。 

不同 
1. wait方法的执行必须在同步方法中进行，而sleep则不需要。 
2. 在同步方法里执行sleep方法时，不会释放monitor锁，但是wait方法会释放monitor锁。 
3. sleep方法短暂休眠之后会主动退出阻塞，而没有指定时间的 wait方法则需要被其他线程中断后才能退出阻塞。 
4. wait()和notify(),notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法

#### 6. 线程安全

你讲讲你理解的“线程安全”是什么？

Java Concurrency In Practice》的作者Brian Goetz对“线程安全”有一个比较恰当的定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。

这句话的意思是：不管业务中遇到怎样的多个线程访问某对象或某方法的情况，而在编程这个业务逻辑的时候，都不需要额外做任何额外的处理（也就是可以像单线程编程一样），程序也可以正常运行（不会因为多线程而出错），就可以称为线程安全。

相反，如果在编程的时候，需要考虑这些线程在运行时的调度和交替（例如在get()调用到期间不能调用set()），或者需要进行额外的同步（比如使用synchronized关键字等），那么就是线程不安全的。
