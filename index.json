[{"categories":["后端技术"],"content":"全文检索概念 1. 什么是全文检索 对 非结构化数据 搜索/结构化数据就要全文检索，狭义的理解主要针对文本数据的搜索。 结构化数据： 业界指关系模型数据，即以关系数据库表形式管理的数据 半结构数据： 非关系模型的、有基本固定结构模式的数据，例如日志文件、XML文档、JSON文档、Email等。 非结构化数据： 没有固定模式的数据，如WORD、PDF、PPT、EXL，各种格式的图片、视频等。 非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，不方便用数据库二维逻辑表来表现的数据。包括所有格式的办公文档、文本、图片、XML, HTML、各类报表、图像和音频/视频信息等等 2. 全文检索的特点 相关度最高的排在最前面，官网中相关的网页排在最前面； java 关键词的高亮。 只处理文本,不处理语义。 以单词方式进行搜索 比如在输入框中输入“中国的首都在哪里”，搜索引擎不会以对话的形式告诉你“在北京”，而仅仅是列出包含了搜索关键字的网页。 ","date":"2018-06-08","objectID":"/full-text-search-engine/:1:0","tags":["java","Lucene","ElasticSearch"],"title":"全文搜索引擎简介","uri":"/full-text-search-engine/"},{"categories":["后端技术"],"content":"全文搜索实现 ","date":"2018-06-08","objectID":"/full-text-search-engine/:2:0","tags":["java","Lucene","ElasticSearch"],"title":"全文搜索引擎简介","uri":"/full-text-search-engine/"},{"categories":["后端技术"],"content":"Lucene 1. 概念 Lucene是apache下的一个开源的全文检索引擎工具包(一堆jar包)。它为软件开发人员提供一个简单易用的工具包（类库），以方便的在小型目标系统中实现全文检索的功能。虽然Lucene是当前业界公认的性能最好的全文搜索引擎，但是它只是一个工具包，你还需要对它进行整合封装进自己的项目中才可以使用，十分的复杂。这里对它进行一个简介。 2. Lucene的工作流程 索引创建 将现实世界中所有的结构化和非结构化数据提取信息，创建索引的过程。那么索引里面究竟存的什么，以及如何创建索引呢？在这通过下面的例子来解答这个问题。 首先构造三个不同的句子，有长有短： 在①处分别为3个句子加上编号，然后进行分词，把被一个单词分解出来与编号对应放在②处；在搜索的过程总，对于搜索的过程中大写和小写指的都是同一个单词，在这就没有区分的必要，按规则统一变为小写放在③处；要加快搜索速度，就必须保证这些单词的排列时有一定规则，这里按照字母顺序排列后放在④处；最后再简化索引，合并相同的单词，就得到如下结果： 通常在数据库中我们都是根据文档找到内容，而这里是通过词，能够快速找到包含他的文档，这就是文档倒排链表。 以上就是lucene索引结构中最核心的部分。我们注意到关键字是按字符顺序排列的（lucene没有使用B树结构），因此lucene可以用二元搜索算法快速定位关键词。 索引搜索 就是得到用户的查询请求，搜索创建的索引，然后返回结果的过程。 比如我们要搜索java world两个关键词，符合java的有1,2两个文档，符合world的有1,3两个文档，在搜索引擎中直接这样排列两个词他们之间是OR的关系，出现其中一个都可以被找到，所以这里3个都会出来。全文检索中是有相关性排序的，那么结果在是怎么排列的呢？hello java world中包含两个关键字排在第一，另两个都包含一个关键字，得到结果，hello lucene world排在第二，java在最长的句子中占的权重最低排在结果集的第三。从这里可以看出相关度排序还是有一定规则的。 3. Lucene的Hello-world基本使用 在 Lucene 中，索引库的创建和维护使用 IndexWriter，而索引库的搜索则使用 IndexSearcher。数据是以 document 的形式保存到 Lucene 中的，一个 document 数据可以理解为是一条数据，而 document 则是由 Field 组成，也就是字段。 创建索引 // 获取保存索引库的位置信息 Path path = Paths.get(\"/Users/chenyangm/Documents/JavaLearning/Day64_LuceneDemo/index\"); // 创建索引库的目录 Directory directory = directory = FSDirectory.open(path); String str1 = \"hello world\"; String str2 = \"hello java\"; String str3 = \"Hello new Java\"; // 定义分词器，这里使用最基本的分词器 IndexWriterConfig indexWriterConfig = new IndexWriterConfig(new SimpleAnalyzer()); // 创建 indexWriter 对象，写入和创建索引 IndexWriter indexWriter = new IndexWriter(directory, indexWriterConfig); // 创建字段 TextField context1 = new TextField(\"context\", str1, Field.Store.YES); TextField context2 = new TextField(\"context\", str2, Field.Store.YES); TextField context3 = new TextField(\"context\", str3, Field.Store.YES); // 定义 document 对象， 一个 document 对象就相当于一条数据 Document doc1 = new Document(); Document doc2 = new Document(); Document doc3 = new Document(); doc1.add(context1); doc2.add(context2); doc3.add(context3); // 写入数据，创建索引 indexWriter.addDocument(doc1); indexWriter.addDocument(doc2); indexWriter.addDocument(doc3); // 提交数据 indexWriter.commit(); // 关闭 indexWriter.close(); 搜索文档 在搜索文档的时候也会对查询短语进行分词，同时根据匹配的程度，进行排序和打分。 // 获取保存索引库的位置信息 Path path = Paths.get(\"/Users/chenyangm/Documents/JavaLearning/Day64_LuceneDemo/index\"); // 创建索引库的目录 Directory directory = directory = FSDirectory.open(path); // 创建默认解析器 QueryParser parser = new QueryParser(\"context\", new SimpleAnalyzer()); // 查询对象 Query query = parser.parse(\"context:hello java\"); // 通过 indexSearch 查询数据 // 创建 indexSearch 对象 IndexReader open = DirectoryReader.open(directory); IndexSearcher indexSearcher = new IndexSearcher(open); // 通过查询对象查询索引 TopDocs topDocs = indexSearcher.search(query, 100); for (ScoreDoc scoreDoc : topDocs.scoreDocs) { float score = scoreDoc.score; int docIndex = scoreDoc.doc; Document doc = indexSearcher.doc(docIndex); System.out.println(\"索引为： \" + docIndex + \" ; 分数为：\" + score + \" ；内容为：\" + doc.get(\"context\")); } ","date":"2018-06-08","objectID":"/full-text-search-engine/:2:1","tags":["java","Lucene","ElasticSearch"],"title":"全文搜索引擎简介","uri":"/full-text-search-engine/"},{"categories":["后端技术"],"content":"ElasticSearch 1. ElasticSearch 简介 虽然全文搜索领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene的配置及使用非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 实际项目中，我们建立一个网站或应用程序，并要添加搜索功能，令我们受打击的是：搜索工作是很难的。我们希望我们的搜索解决方案要快，我们希望有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON/XML通过HTTP的索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并在需要扩容时方便地扩展到数百，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。 ES即为了解决原生Lucene使用的不足，优化Lucene的调用方式，并实现了高可用的分布式集群的搜索方案，其第一个版本于2010年2月出现在GitHub上并迅速成为最受欢迎的项目之一。 首先，ES的索引库管理支持依然是基于Apache Lucene(TM)的开源搜索引擎。ES也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 不过，ES的核心不在于Lucene，其特点更多的体现为： 分布式的实时文件存储，每个字段都被索引并可被搜索 分布式的实时分析搜索引擎 可以扩展到上百台服务器，处理PB级结构化或非结构化数据：KB-MB-GB-TB-PB 高度集成化的服务，你的应用可以通过简单的 RESTful API、各种语言的客户端甚至命令行与之交互。 2. ElasticSearch使用 1. 安装ElasticSearch 这里为了学习和测试，所以使用docker来进行安装，同时版本也是安装的最新版本 7.8.0 版本。 docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -e \"discovery.type=single-node\" --restart=always --name elasticsearch-dev elasticsearch:7.8.0 同时也可以将 kibana 安装上，用来进行测试。 docker run --restart=always --link elasticsearch-dev:elasticsearch -d -p 5601:5601 kibana:7.8.0 2. ElasticSearch 简单使用 ElasticSearch使用 restful 风格的 API 来进行操作的，这里我们简单的使用一下 Tips: 需要注意的是 在 ElasticSearch 7.8 的版本中 ，_type 属性被移除了。根据官网的解释，在 ES最初开发的时候，借用了关系型数据库的一些概念，比如说 index 类比为库， type 类比为表 document 则类比为 一行数据。但是在 Lucene 中，是没有 type 这个概念的，所以如果 不同 type 中 多个字段相同的话则会发生冲突，会在查询的时候都进行搜索。 关于解决方案： 使用多个index，将不同类型的数据放到不同的index中 使用 mapping 自定义属性 2.1 基本的增删改 # 创建一个index PUT /employee # 创建一个元素 PUT /employee/_doc/1 { \"name\": \"老王\", \"age\": 18 } #批量创建元素 PUT /employee/_bulk?pretty\u0026\u0026refresh {\"index\": {\"_id\": 2}} {\"name\": \"老孙2\", \"age\": \"19\"} {\"index\": {\"_id\": 3}} {\"name\": \"老孙3\", \"age\": \"20\"} {\"index\": {\"_id\": 4}} {\"name\": \"老王2\", \"age\": \"31\"} # 更新一个元素 这个会强制更新所有的内容，如果字段被删除了则更新后也会被删除 POST /employee/_doc/2 { \"name\": \"老王1\" } # 更新部分的文档 只会更新当前字段不会进行覆盖 POST /employee/_update/2 { \"doc\": { \"age\": 12, \"count\": 14 } } # 更新部分的文档 POST /employee/_update/2 { \"doc\": { \"count\": 20 } } # 使用脚本进行更新，可以进行简单的计算 POST /employee/_update/2 { \"script\": \"ctx._source.count += 1\" } # 批量获取 GET /employee/_mget { \"ids\": [\"1\", \"2\", \"3\"] } #删除一个元素 DELETE /employee/_doc/1 #删除index DELETE /employee/ # 获取一个元素 GET /employee/_doc/1 # 查找所有的元素 GET /employee/_search # 以年龄进行倒序排列 GET /employee/_search { \"query\": {\"match_all\": {}}, \"sort\": { \"age\": \"desc\" } } # 批量插入大量数据 PUT /account/_bulk # 使用uri进行简单的查询 GET /account/_search?q=account_number:1 # 使用_source 对返回的数据进行限制 GET /account/_search?q=account_number:1\u0026\u0026_source=account_number,firstname 2.2 DSL查询相关 DSL 是 ES 的一种查询语法，可以对 ES 进行复杂查询。 在 ES 中，查询分为 DSL 查询和 DSL 过滤。 DSL查询和DSL过滤的区别 DSL 查询 在查询上下文中，查询子句回答以下问题：“此文档与该查询子句的匹配程度如何？”。除了确定文档是否匹配之外，查询子句还计算_score元字段中的相关性得分。 只要将查询子句传递到查询参数（例如搜索API中的查询参数），查询上下文就有效。 DSL 过滤 在过滤器上下文中，查询子句回答问题“此文档是否与此查询子句匹配？” 答案是简单的“是”或“否”，即不计算分数。 过滤器上下文主要用于过滤结构化数据，例如 此时间戳记是否在2015年至2016年的范围内？ 状态字段设置为“已发布”吗？ 常用过滤器将由Elasticsearch自动缓存，以提高性能。 只要将查询子句传递到过滤器参数（例如bool查询中的filter或must_not参数，constant_score查询中的filter参数或过滤器聚合），过滤器上下文即有效。 关于 match 和 term的区别 term 先看看term的定义，term是代表完全匹配，也就是精确查询，搜索前不会再对搜索词进行分词拆解。可以先看几个例子: 如果执行下面的搜索 GET /account/_search { \"query\": { \"term\": { \"address\": \"kings\" } } } 我们可以查出来下面的数据 { \"_index\" : \"account\", \"_type\" : \"_doc\", \"_id\" : \"20\", \"_score\" : 5.990829, \"_source\" : { \"age\" : 36, \"gender\" : \"M\", \"address\" : \"282 Kings Place\", \"employer\" : \"Scentric\", \"city\" : \"Ribera\", \"state\" : \"WA\" } } 但是如果我们搜索 \"address\": \"Kings\" 这个语句的话，我们搜索出来的就是一个空的文档。因为 address 这个字段在保存的时候已经进行了分词的操作，会将单词转为小写，而使用 term 进行查询的话，是不会对查询语句进行分词操作的，所以还是会去匹配 Kings 这个关键字，自然匹配不到。 而如果我们需要匹配多个词呢，使用 term 还能够帮我们匹配出来吗。答案是不能的。我们可以尝试一下 GET /account/_search { \"query\": { \"term\": { \"address\": \"kings place\" } } } 查出来的结果如下 { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : { \"value\" : 0, \"relation\" : \"eq\" }, \"max_score\" : null, \"hits\" : [ ] } } 执行发现无数据，从概念上看，term属于精确匹配，只能查单个词。我想用term匹配多个词怎么做？可以使用terms来： GET /account/_search { \"query\": { \"terms\": { \"address\": [\"kings","date":"2018-06-08","objectID":"/full-text-search-engine/:2:2","tags":["java","Lucene","ElasticSearch"],"title":"全文搜索引擎简介","uri":"/full-text-search-engine/"}]