[{"categories":["后端技术","java基础"],"content":"1. 线程的8大核心基础知识 1.实现多线程的几种方式 实现多线程的正确方法是2种： 实现 Runnable 接口 继承 Thread 类 实现Runnable接口好在哪里？ 继承Thread类是不推荐的，因为它有以下的一些缺点： 从代码架构角度：具体的任务（run方法）应该和“创建和运行线程的机制（Thread类）”解耦，用runnable对象可以实现解耦。 使用继承Thread的方式的话，那么每次想新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大（比如重头开始创建一个线程、执行完毕以后再销毁等。如果线程的实际工作内容，也就是run()函数里只是简单的打印一行文字的话，那么可能线程的实际工作内容还不如损耗来的大）。如果使用Runnable和线程池，就可以大大减小这样的损耗。 继承Thread类以后，由于Java语言不支持双继承，这样就无法再继承其他的类，限制了可扩展性。 通常我们优先选择方法1。 两种方法的本质对比 方法一和方法二，也就是“实现Runnable接口并传入Thread类”和“继承Thread类然后重写run()”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源： @Override public void run() { if (target != null) { target.run(); } } 方法一：最终调用target.run(); 方法二：run()整个都被重写 有多少种实现线程的方法？ 答题思路，以下5点： 从不同的角度看，会有不同的答案。 典型答案是两种，分别是实现Runnable接口和继承Thread类，然后具体展开说； 但是，我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的， run方法的代码如下： @Override public void run() { if (target != null) { target.run(); } } 方法一和方法二，也就是“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源： 方法一：最终调用target.run(); 方法二：run()整个都被重写 然后具体展开说其他方式； 还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。 结论:我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现。第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnable实例传给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是它们的本质都逃不出刚才所说的范围。 以上这种描述比直接回答一种、两种、多种都更准确。 2. 启动线程的方式 start() 和 run() 方法的比较 正确的启动线程的方式是调用 start() 方法，而直接调用 run() 方法和调用普通方法没有任何区别 start方法的执行流程是什么？ 检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行中或者已结束的线程，都不能再次启动，详见CantStartTwice10类） 将当前线程加入到线程组 调用start0()方法启动线程 注意点： start方法是被synchronized修饰的方法，可以保证线程安全； 由JVM创建的main方法线程和system组线程，并不会通过start来启动。 3. 如何正确停止线程 Java中停止线程的原则是什么？ 在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该停止运行了”，被终止的线程自身拥有决定权（决定是否、以及何时停止），这依赖于请求停止方和被停止方都遵守一种约定好的编码规范。 任务和线程的启动很容易。在大多数时候,我们都会让它们运行直到结束,或者让它们自行停止。然而,有时候我们希望提前结束任务或线程,或许是因为用户取消了操作,或者服务需要被快速关闭，或者是运行超时或出错了。 要使任务和线程能安全、快速、可靠地停止下来,并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断( Interruption),这是一种协作机制,能够使一个线程终止另一个线程的当前工作。 这种协作式的方法是必要的,我们很少希望某个任务、线程或服务立即停止,因为这种立即停止会使共享的数据结构处于不一致的状态。相反,在编写任务和服务时可以使用一种协作的方式:当需要停止时,它们首先会清除当前正在执行的工作,然后再结束。这提供了更好的灵活性,因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。 生命周期结束(End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂,而这个在程序设计中非常重要的要素却经常被忽略。一个在行为良好的软件与勉强运的软件之间的最主要区别就是,行为良好的软件能很完善地处理失败、关闭和取消等过程。 处理中断的最好方法是什么？ 优先选择在方法上抛出异常。 用throws InterruptedException 标记你的方法，不采用try 语句块捕获异常，以便于该异常可以传递到顶层，让run方法可以捕获这一异常，例如： void subTask() throws InterruptedException { sleep(delay); } 由于run方法内无法抛出checked Exception（只能用try catch），顶层方法必须处理该异常，避免了漏掉或者被吞掉的情况，增强了代码的健壮性。 如果不能抛出中断，要怎么做？ 如果不想或无法传递InterruptedException（例如用run方法的时候，就不让该方法throws InterruptedException），那么应该选择在catch 子句中调用Thread.currentThread().interrupt() 来恢复设置中断状态，以便于在后续的执行依然能够检查到刚才发生了中断。 线程在sleep期间被中断，并且由catch捕获到该中断，并重新设置了中断状态，以便于可以在下一个循环的时候检测到中断状态，正常退出。 为什么用volatile停止线程不够全面 解答：这种做法是错误的，或者说是不够全面的，在某些情况下虽然可用，但是某些情况下有严重问题。 这种方法在《Java并发编程实战》中被明确指出了缺陷，我们一起来看看缺陷在哪里： 此方法错误的原因在于，如果我们遇到了线程长时间阻塞（这是一种很常见的情况，例如生产者消费者模式中就存在这样的情况），就没办法及时唤醒它，或者永远都无法唤醒该线程，而interrupt设计之初就是把wait等长期阻塞作为一种特殊情况考虑在内了，我们应该用interrupt思维来停止线程。 面试题1: 如何停止线程？ 原理：用interrupt来请求线程停止而不是强制，好处是安全。 想停止线程，要请求方、被停止方、子方法被调用方相互配合才行： a) 作为被停止方：每次循环中或者适时检查中断信号，并且在可能抛出InterrupedException的地方处理该中断信号； b) 请求方：发出中断信号； c) 子方法调用方（被线程调用的方法的作者）要注意：优先在方法层面抛出InterrupedException，或者检查到中断信号时，再次设置中断状态； 最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况 面试题2: 无法响应中断时如何停止线程？ 如果线程阻塞是由于调用了 wait()，sleep() 或 join() 方法，你可以中断线程，通过抛出 InterruptedException 异常来唤醒该线程。 但是对于不能响应InterruptedException的阻塞，很遗憾，并没有一个通用的解决方案。 但是我们可以利用特定的其它的可以响应中断的方法，比如ReentrantLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。 答案有很多种，因为有很多原因会造成线程阻塞，所以针对不同情况，唤起的方法也不同。 总结就是说如果不支持响应中断，就要用特定方法来唤起，没有万能药。 4. 线程的生命周期 答题思路： 先讲6个圆圈内的状态名，再讲转换路径（例如new只能跳转到runnable），最后讲转移条件。 5. Object的wait/notify/notifyAll以及Thread的sleep的特点 讲讲sleep方法的特点？ sleep方法可以让线程进入Timed_Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态。 wait和sleep方法的异同？ 你知道wait和sleep方法的异同吗？ 解答： 相同 Wait和sleep方法都可以使线程阻塞，对应线程状态是Waiting或Time_Waiting。 wait和sleep方法都可以响应中断Thread.interrupt()。 不同 wait方法的执行必须在同步方法中进行，而sleep则不需要。 在同步方","date":"2018-06-19","objectID":"/java-basic-thread/:0:1","tags":["java","并发"],"title":"java基础并发系列-初识线程","uri":"/java-basic-thread/"},{"categories":["后端技术"],"content":"1. 认识权限 1. 什么是权限 权限在一个系统中占据着十分重要的地位，一些功能只有特定角色用户才能访问，要做权限判断。 2. 权限的分类 登录权限 这个是所有权限的基础，也是接触最多的权限了， 所以这里就不在描述了 功能系权限 对每个用户的系统权限精准控制。不同的人拥有不同的权限。 粗粒度权限管理，对资源类型的权限管理。资源类型比如：菜单、url连接、用户添加页面、用户信息、类方法、页面中按钮。 如：超级管理员可以访问用户添加页面、用户信息等全部页面。 部门管理员可以访问用户信息页面包括 页面中所有按钮。 细粒度权限管理，对资源实例的权限管理。数据级别的权限管理。如：部门经理只可以访问本部门的员工基本信息但不能查看身份证，用户只可以看到自己的全部信息。 ","date":"2018-06-10","objectID":"/rbac-simple-permission-system/:0:1","tags":["权限","rbac"],"title":"权限系统初识-基于rbac模型设计一个简单的权限","uri":"/rbac-simple-permission-system/"},{"categories":["后端技术"],"content":"2. 权限的设计原理 1. RBAC 权限模型 权限的设计模型有很多方式，本案例中使用的是 RBAC 权限模型。RBAC 权限模型就是基于角色的访问控制。其基本思想是，对系统操作的各种权限不是直接授予具体的用户，而是在用户集合与权限集合之间建立一个角色集合。每一种角色对应一组相应的权限。一旦用户被分配了适当的角色后，该用户就拥有此角色的所有操作权限。这样做的好处是，不必在每次创建用户时都进行分配权限的操作，只要分配用户相应的角色即可，而且角色的权限变更比用户的权限变更要少得多，这样将简化用户的权限管理，减少系统的开销。 模型设计： 用户—\u003e 角色 —\u003e 权限 —\u003e 功能 而用户和角色 角色和权限 从双方的角度看都是多对多的关系，所以都需要添加中间表进行关联 模型设计： 用户—\u003e用户角色关联表—\u003e角色—\u003e角色权限关联表—\u003e权限—\u003e功能 优点：简化权限和用户之间的关系，易扩展和维护。 2. domain之间的关系分析 用户与角色：站在用户的角度，一个用户可能存在多个角色。站在角色的角度，一个角色有多个用户。用户与角色多对多的关系。 角色与权限：多对多的关系。 ","date":"2018-06-10","objectID":"/rbac-simple-permission-system/:0:2","tags":["权限","rbac"],"title":"权限系统初识-基于rbac模型设计一个简单的权限","uri":"/rbac-simple-permission-system/"},{"categories":["后端技术"],"content":"3. 项目解析 这里对项目中的一些思路和一些知识点进行一个总结，而关于前端的一些内容这里就不做描述了 1. Mybatis的分页插件 - PageHelper PageHelper是Mybatis集成的一款分页插件。支持常见的RowBounds(PageRowBounds)， PageHelper.startPage 方法调用，Mapper 接口参数调用等等，使用起来十分方便。 在 maven 中导入依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.2.5\u003c/version\u003e \u003c/dependency\u003e 使用 PageHelper.startPage() 来进行分页 PageHelper.startPage(startPage, limitSize) 这个方法在调用之后会自动的将紧跟着 startPage 之后的第一个 select 语句进行分页，同时会将集合封装成 Page 对象。同时在 Page 对象中有查询条数、查询结果等等一系列的结果。 //要进行分页 PageHelper.startPage(roleQuery.getCurrentPage(),roleQuery.getPageSize()); //查询数据 List\u003cRole\u003e roles = roleMapper.selectAllByRoleName(roleQuery.getRoleName()); PageInfo结果封装。 PageInfo 类是对 Page 结果的进一步封装。里面提供了很多实用的属性例如是否是最后一页，是否是第一页等等。。 要使用 PageInfo 作为返回结果只需要在 进行一次封装就可以。 //把集合封装到PageInfo里面 PageInfo\u003cRole\u003e pageInfo = new PageInfo\u003c\u003e(roles); PageHelper的函数式接口，ISelect 接口方式 doSelectPage() Page\u003cCountry\u003e page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() { @Override public void doSelect() { countryMapper.selectGroupBy(); } }); //jdk8 lambda用法 Page\u003cCountry\u003e page = PageHelper.startPage(1, 10).doSelectPage(()-\u003e countryMapper.selectGroupBy()); doSelectPageInfo() //也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPage pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() { @Override public void doSelect() { countryMapper.selectGroupBy(); } }); //对应的lambda用法 pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -\u003e countryMapper.selectGroupBy()); 2. 对角色进行授权 角色授权页面的一个主要的点就是对权限的父权限和子权限进行封装。这里是要进行自关联查询， 要以父权限为主表。 SELECTparent.*,child.idchild_id,child.namechild_nameFROMpermissionparentLEFTJOINpermissionchildONparent.id=child.parent_idWHEREparent.parent_idisnull 而将结果封装到 domain 中去的话还需要进行一个 结果集的映射 public class Permission { private Long id; //权限名 private String name; //权限url地址 private String url; //权限对应的菜单 private Menu menu; //子权限对应的父权限 private Permission parent; //装子权限的 private List\u003cPermission\u003e children = new ArrayList\u003c\u003e(); } \u003cresultMap id=\"selectAllPermissionsType\" type=\"Permission\"\u003e \u003cid column=\"id\" property=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003cresult property=\"url\" column=\"url\"/\u003e \u003ccollection property=\"children\" columnPrefix=\"child_\" ofType=\"Permission\"\u003e \u003cid column=\"id\" property=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 而回显的话，则是根据 角色id 直接查询 role_permission 关联表就可以了，如果要稳妥一点可以在 关联 permission表，从 permission 表中获取其权限id。 3. 授权的保存 为了简化逻辑，可以在授权的时候直接将 当前角色的所有权限全部删除，在重新授权保存role_permission表中的数据。 4. 动态菜单的一个实现 动态菜单的实现主要还是多表查询，根据用户id查出对应的角色信息，而通过角色信息查出权限，最后在根据权限就可以筛选出对应权限的菜单了。 当然这里的 sql 只是一个示例。 SELECTm.*,mp.idmp_id,mp.namemp_name,mp.urlmp_urlFROMemployeeeJOINemployee_roleerONe.id=er.employee_idJOINrole_permissionrpONrp.role_id=er.role_idJOINpermissionpONrp.permission_id=p.idJOINmenumONp.menu_id=m.idJOINmenumpONm.parent_id=mp.idWHEREe.id=#{id} 将结果封装到 domain 中 public class Menu { /**主键id*/ private Long id; /**菜单名*/ private String name; /**菜单url*/ private String url; /**菜单图标*/ private String icon; /**父及菜单*/ private Menu parentMenu; /**子菜单*/ private List\u003cMenu\u003e children = new ArrayList\u003c\u003e(); } \u003cresultMap id=\"menuType\" type=\"Menu\"\u003e \u003cid column=\"id\" property=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003cresult property=\"url\" column=\"url\"/\u003e \u003cresult property=\"icon\" column=\"icon\"/\u003e \u003cassociation property=\"parentMenu\" javaType=\"Menu\" columnPrefix=\"mp_\"\u003e \u003cid column=\"id\" property=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003cresult property=\"url\" column=\"url\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e 而由于前台需要的数据格式是 父菜单-子菜单，所以还需要在进行一层封装 //创建一个空集合(专门来装一级菜单的) List\u003cMenu\u003e parents = new ArrayList\u003c\u003e(); List\u003cMenu\u003e menus = menuMapper.selectMenuByEmployeeId(employee.getId()); //定义一个map集合，该map集合是专门来装父级菜单的 Map\u003cLong, Menu\u003e map = new HashMap\u003c\u003e(); for (Menu menu : menus) { //父级菜单 Menu parent = menu.getParent(); //判断map key中是否有父菜单对应的id,如果没有，则把父菜单添加到map集合中 if(!map.containsKey(parent.getId())){ map.put(parent.getId(), parent); } //拿到对应的父菜单 Menu p = map.get(parent.getId()); //父菜单获取到子菜单集合之后，再进行添加子菜单 p.getChildren().add","date":"2018-06-10","objectID":"/rbac-simple-permission-system/:0:3","tags":["权限","rbac"],"title":"权限系统初识-基于rbac模型设计一个简单的权限","uri":"/rbac-simple-permission-system/"},{"categories":["后端技术"],"content":"全文检索概念 1. 什么是全文检索 对 非结构化数据 搜索/结构化数据就要全文检索，狭义的理解主要针对文本数据的搜索。 结构化数据： 业界指关系模型数据，即以关系数据库表形式管理的数据 半结构数据： 非关系模型的、有基本固定结构模式的数据，例如日志文件、XML文档、JSON文档、Email等。 非结构化数据： 没有固定模式的数据，如WORD、PDF、PPT、EXL，各种格式的图片、视频等。 非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，不方便用数据库二维逻辑表来表现的数据。包括所有格式的办公文档、文本、图片、XML, HTML、各类报表、图像和音频/视频信息等等 2. 全文检索的特点 相关度最高的排在最前面，官网中相关的网页排在最前面； java 关键词的高亮。 只处理文本,不处理语义。 以单词方式进行搜索 比如在输入框中输入“中国的首都在哪里”，搜索引擎不会以对话的形式告诉你“在北京”，而仅仅是列出包含了搜索关键字的网页。 ","date":"2018-06-08","objectID":"/full-text-search-engine/:1:0","tags":["java","Lucene","ElasticSearch"],"title":"全文搜索引擎简介","uri":"/full-text-search-engine/"},{"categories":["后端技术"],"content":"全文搜索实现 ","date":"2018-06-08","objectID":"/full-text-search-engine/:2:0","tags":["java","Lucene","ElasticSearch"],"title":"全文搜索引擎简介","uri":"/full-text-search-engine/"},{"categories":["后端技术"],"content":"Lucene 1. 概念 Lucene是apache下的一个开源的全文检索引擎工具包(一堆jar包)。它为软件开发人员提供一个简单易用的工具包（类库），以方便的在小型目标系统中实现全文检索的功能。虽然Lucene是当前业界公认的性能最好的全文搜索引擎，但是它只是一个工具包，你还需要对它进行整合封装进自己的项目中才可以使用，十分的复杂。这里对它进行一个简介。 2. Lucene的工作流程 索引创建 将现实世界中所有的结构化和非结构化数据提取信息，创建索引的过程。那么索引里面究竟存的什么，以及如何创建索引呢？在这通过下面的例子来解答这个问题。 首先构造三个不同的句子，有长有短： 在①处分别为3个句子加上编号，然后进行分词，把被一个单词分解出来与编号对应放在②处；在搜索的过程总，对于搜索的过程中大写和小写指的都是同一个单词，在这就没有区分的必要，按规则统一变为小写放在③处；要加快搜索速度，就必须保证这些单词的排列时有一定规则，这里按照字母顺序排列后放在④处；最后再简化索引，合并相同的单词，就得到如下结果： 通常在数据库中我们都是根据文档找到内容，而这里是通过词，能够快速找到包含他的文档，这就是文档倒排链表。 以上就是lucene索引结构中最核心的部分。我们注意到关键字是按字符顺序排列的（lucene没有使用B树结构），因此lucene可以用二元搜索算法快速定位关键词。 索引搜索 就是得到用户的查询请求，搜索创建的索引，然后返回结果的过程。 比如我们要搜索java world两个关键词，符合java的有1,2两个文档，符合world的有1,3两个文档，在搜索引擎中直接这样排列两个词他们之间是OR的关系，出现其中一个都可以被找到，所以这里3个都会出来。全文检索中是有相关性排序的，那么结果在是怎么排列的呢？hello java world中包含两个关键字排在第一，另两个都包含一个关键字，得到结果，hello lucene world排在第二，java在最长的句子中占的权重最低排在结果集的第三。从这里可以看出相关度排序还是有一定规则的。 3. Lucene的Hello-world基本使用 在 Lucene 中，索引库的创建和维护使用 IndexWriter，而索引库的搜索则使用 IndexSearcher。数据是以 document 的形式保存到 Lucene 中的，一个 document 数据可以理解为是一条数据，而 document 则是由 Field 组成，也就是字段。 创建索引 // 获取保存索引库的位置信息 Path path = Paths.get(\"/Users/chenyangm/Documents/JavaLearning/Day64_LuceneDemo/index\"); // 创建索引库的目录 Directory directory = directory = FSDirectory.open(path); String str1 = \"hello world\"; String str2 = \"hello java\"; String str3 = \"Hello new Java\"; // 定义分词器，这里使用最基本的分词器 IndexWriterConfig indexWriterConfig = new IndexWriterConfig(new SimpleAnalyzer()); // 创建 indexWriter 对象，写入和创建索引 IndexWriter indexWriter = new IndexWriter(directory, indexWriterConfig); // 创建字段 TextField context1 = new TextField(\"context\", str1, Field.Store.YES); TextField context2 = new TextField(\"context\", str2, Field.Store.YES); TextField context3 = new TextField(\"context\", str3, Field.Store.YES); // 定义 document 对象， 一个 document 对象就相当于一条数据 Document doc1 = new Document(); Document doc2 = new Document(); Document doc3 = new Document(); doc1.add(context1); doc2.add(context2); doc3.add(context3); // 写入数据，创建索引 indexWriter.addDocument(doc1); indexWriter.addDocument(doc2); indexWriter.addDocument(doc3); // 提交数据 indexWriter.commit(); // 关闭 indexWriter.close(); 搜索文档 在搜索文档的时候也会对查询短语进行分词，同时根据匹配的程度，进行排序和打分。 // 获取保存索引库的位置信息 Path path = Paths.get(\"/Users/chenyangm/Documents/JavaLearning/Day64_LuceneDemo/index\"); // 创建索引库的目录 Directory directory = directory = FSDirectory.open(path); // 创建默认解析器 QueryParser parser = new QueryParser(\"context\", new SimpleAnalyzer()); // 查询对象 Query query = parser.parse(\"context:hello java\"); // 通过 indexSearch 查询数据 // 创建 indexSearch 对象 IndexReader open = DirectoryReader.open(directory); IndexSearcher indexSearcher = new IndexSearcher(open); // 通过查询对象查询索引 TopDocs topDocs = indexSearcher.search(query, 100); for (ScoreDoc scoreDoc : topDocs.scoreDocs) { float score = scoreDoc.score; int docIndex = scoreDoc.doc; Document doc = indexSearcher.doc(docIndex); System.out.println(\"索引为： \" + docIndex + \" ; 分数为：\" + score + \" ；内容为：\" + doc.get(\"context\")); } ","date":"2018-06-08","objectID":"/full-text-search-engine/:2:1","tags":["java","Lucene","ElasticSearch"],"title":"全文搜索引擎简介","uri":"/full-text-search-engine/"},{"categories":["后端技术"],"content":"ElasticSearch 1. ElasticSearch 简介 虽然全文搜索领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene的配置及使用非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 实际项目中，我们建立一个网站或应用程序，并要添加搜索功能，令我们受打击的是：搜索工作是很难的。我们希望我们的搜索解决方案要快，我们希望有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON/XML通过HTTP的索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并在需要扩容时方便地扩展到数百，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。 ES即为了解决原生Lucene使用的不足，优化Lucene的调用方式，并实现了高可用的分布式集群的搜索方案，其第一个版本于2010年2月出现在GitHub上并迅速成为最受欢迎的项目之一。 首先，ES的索引库管理支持依然是基于Apache Lucene(TM)的开源搜索引擎。ES也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 不过，ES的核心不在于Lucene，其特点更多的体现为： 分布式的实时文件存储，每个字段都被索引并可被搜索 分布式的实时分析搜索引擎 可以扩展到上百台服务器，处理PB级结构化或非结构化数据：KB-MB-GB-TB-PB 高度集成化的服务，你的应用可以通过简单的 RESTful API、各种语言的客户端甚至命令行与之交互。 2. ElasticSearch使用 1. 安装ElasticSearch 这里为了学习和测试，所以使用docker来进行安装，同时版本也是安装的最新版本 7.8.0 版本。 docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -e \"discovery.type=single-node\" --restart=always --name elasticsearch-dev elasticsearch:7.8.0 同时也可以将 kibana 安装上，用来进行测试。 docker run --restart=always --link elasticsearch-dev:elasticsearch -d -p 5601:5601 kibana:7.8.0 2. ElasticSearch 简单使用 ElasticSearch使用 restful 风格的 API 来进行操作的，这里我们简单的使用一下 Tips: 需要注意的是 在 ElasticSearch 7.8 的版本中 ，_type 属性被移除了。根据官网的解释，在 ES最初开发的时候，借用了关系型数据库的一些概念，比如说 index 类比为库， type 类比为表 document 则类比为 一行数据。但是在 Lucene 中，是没有 type 这个概念的，所以如果 不同 type 中 多个字段相同的话则会发生冲突，会在查询的时候都进行搜索。 关于解决方案： 使用多个index，将不同类型的数据放到不同的index中 使用 mapping 自定义属性 2.1 基本的增删改 # 创建一个index PUT /employee # 创建一个元素 PUT /employee/_doc/1 { \"name\": \"老王\", \"age\": 18 } #批量创建元素 PUT /employee/_bulk?pretty\u0026\u0026refresh {\"index\": {\"_id\": 2}} {\"name\": \"老孙2\", \"age\": \"19\"} {\"index\": {\"_id\": 3}} {\"name\": \"老孙3\", \"age\": \"20\"} {\"index\": {\"_id\": 4}} {\"name\": \"老王2\", \"age\": \"31\"} # 更新一个元素 这个会强制更新所有的内容，如果字段被删除了则更新后也会被删除 POST /employee/_doc/2 { \"name\": \"老王1\" } # 更新部分的文档 只会更新当前字段不会进行覆盖 POST /employee/_update/2 { \"doc\": { \"age\": 12, \"count\": 14 } } # 更新部分的文档 POST /employee/_update/2 { \"doc\": { \"count\": 20 } } # 使用脚本进行更新，可以进行简单的计算 POST /employee/_update/2 { \"script\": \"ctx._source.count += 1\" } # 批量获取 GET /employee/_mget { \"ids\": [\"1\", \"2\", \"3\"] } #删除一个元素 DELETE /employee/_doc/1 #删除index DELETE /employee/ # 获取一个元素 GET /employee/_doc/1 # 查找所有的元素 GET /employee/_search # 以年龄进行倒序排列 GET /employee/_search { \"query\": {\"match_all\": {}}, \"sort\": { \"age\": \"desc\" } } # 批量插入大量数据 PUT /account/_bulk # 使用uri进行简单的查询 GET /account/_search?q=account_number:1 # 使用_source 对返回的数据进行限制 GET /account/_search?q=account_number:1\u0026\u0026_source=account_number,firstname 2.2 DSL查询相关 DSL 是 ES 的一种查询语法，可以对 ES 进行复杂查询。 在 ES 中，查询分为 DSL 查询和 DSL 过滤。 DSL查询和DSL过滤的区别 DSL 查询 在查询上下文中，查询子句回答以下问题：“此文档与该查询子句的匹配程度如何？”。除了确定文档是否匹配之外，查询子句还计算_score元字段中的相关性得分。 只要将查询子句传递到查询参数（例如搜索API中的查询参数），查询上下文就有效。 DSL 过滤 在过滤器上下文中，查询子句回答问题“此文档是否与此查询子句匹配？” 答案是简单的“是”或“否”，即不计算分数。 过滤器上下文主要用于过滤结构化数据，例如 此时间戳记是否在2015年至2016年的范围内？ 状态字段设置为“已发布”吗？ 常用过滤器将由Elasticsearch自动缓存，以提高性能。 只要将查询子句传递到过滤器参数（例如bool查询中的filter或must_not参数，constant_score查询中的filter参数或过滤器聚合），过滤器上下文即有效。 关于 match 和 term的区别 term 先看看term的定义，term是代表完全匹配，也就是精确查询，搜索前不会再对搜索词进行分词拆解。可以先看几个例子: 如果执行下面的搜索 GET /account/_search { \"query\": { \"term\": { \"address\": \"kings\" } } } 我们可以查出来下面的数据 { \"_index\" : \"account\", \"_type\" : \"_doc\", \"_id\" : \"20\", \"_score\" : 5.990829, \"_source\" : { \"age\" : 36, \"gender\" : \"M\", \"address\" : \"282 Kings Place\", \"employer\" : \"Scentric\", \"city\" : \"Ribera\", \"state\" : \"WA\" } } 但是如果我们搜索 \"address\": \"Kings\" 这个语句的话，我们搜索出来的就是一个空的文档。因为 address 这个字段在保存的时候已经进行了分词的操作，会将单词转为小写，而使用 term 进行查询的话，是不会对查询语句进行分词操作的，所以还是会去匹配 Kings 这个关键字，自然匹配不到。 而如果我们需要匹配多个词呢，使用 term 还能够帮我们匹配出来吗。答案是不能的。我们可以尝试一下 GET /account/_search { \"query\": { \"term\": { \"address\": \"kings place\" } } } 查出来的结果如下 { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : { \"value\" : 0, \"relation\" : \"eq\" }, \"max_score\" : null, \"hits\" : [ ] } } 执行发现无数据，从概念上看，term属于精确匹配，只能查单个词。我想用term匹配多个词怎么做？可以使用terms来： GET /account/_search { \"query\": { \"terms\": { \"address\": [\"kings","date":"2018-06-08","objectID":"/full-text-search-engine/:2:2","tags":["java","Lucene","ElasticSearch"],"title":"全文搜索引擎简介","uri":"/full-text-search-engine/"}]